// =================================================================
//  class: CUT_IMAP4Client
//  File:  IMAP4_c.h
//  
//  Purpose:
//
//  IMAP4rev1 Client Class declaration
//  
//  RFC  1730, 2060
//      
// ===================================================================
// Ultimate TCP/IP v4.2
// This software along with its related components, documentation and files ("The Libraries")
// is © 1994-2007 The Code Project (1612916 Ontario Limited) and use of The Libraries is
// governed by a software license agreement ("Agreement").  Copies of the Agreement are
// available at The Code Project (www.codeproject.com), as part of the package you downloaded
// to obtain this file, or directly from our office.  For a copy of the license governing
// this software, you may contact us at legalaffairs@codeproject.com, or by calling 416-849-8900.
// ===================================================================


#ifndef IMAP4_CLIENT_H_ENUM
#define IMAP4_CLIENT_H_ENUM


/********************************
 SystemFlags enum
*********************************/
typedef enum SystemFlagsTag {
    SYS_FLAG_ANSWERED   = 1,
    SYS_FLAG_FLAGGED    = 2,
    SYS_FLAG_DELETED    = 4,
    SYS_FLAG_SEEN       = 8,
    SYS_FLAG_DRAFT      = 16,
    SYS_FLAG_RECENT     = 32,
    SYS_FLAG_SPECIAL    = 64
    } SystemFlags;

/********************************
 FetchItem enum
*********************************/
typedef enum FetchItemTag {
    MSG_BODY         = 0,
    MSG_BODY_TEXT,
    MSG_BODY_HEADER
    } FetchItem;

/********************************
 StoreType enum
*********************************/
typedef enum StoreTypeTag {
    STORE_FLAG_REPLACE      = 0,
    STORE_FLAG_REPLACE_NO_RETURN,
    STORE_FLAG_ADD,
    STORE_FLAG_ADD_NO_RETURN,
    STORE_FLAG_REMOVE,
    STORE_FLAG_REMOVE_NO_RETURN
    } StoreType;

/********************************
 ClientState enum
*********************************/
typedef enum ClientStateTag {
    STATE_NON_AUTHENTICATED,
    STATE_AUTHENTICATED,
    STATE_SELECTED,
    STATE_LOGOUT
    } ClientState;

/********************************
 NameAttrib enum
*********************************/
typedef enum NameAttribTag {
    NAME_ATTRIB_NOINFERIORS = 1,
    NAME_ATTRIB_NOSELECT    = 2,
    NAME_ATTRIB_MARKED      = 4,
    NAME_ATTRIB_UNMARKED    = 8
    } NameAttrib;

#endif  // #ifndef IMAP4_CLIENT_H_ENUM

#ifndef __midl


#ifndef IMAP4_CLIENT_H
#define IMAP4_CLIENT_H


#include "ut_clnt.h"   
#include "UTMessage.h"   

#include <process.h>


// suppress level 4 warnings generated by STL - Transitional for VC6 support
#pragma warning ( push, 3 )		
#pragma warning (disable : 4018 4146 ) 
#include <string>
#pragma warning (pop)
#pragma warning ( push, 3 )	
#pragma warning (disable : 4018)
#include <vector>
#pragma warning (pop)

#define     MAX_LINE_BUFFER     1000
#define     MAX_DATE_TIME_SIZE  100
#define     MAX_TAG_SIZE        6

using namespace std ;

/********************************
 CUT_MailBoxListItem class
*********************************/
class CUT_MailBoxListItem {
public:
    CUT_MailBoxListItem() : m_nNameAttrib(0) {}

    int         m_nNameAttrib;      // Name attribute
    string      m_strDelimiter;     // Name delimiter
    string      m_strName;          // Name
};

typedef vector<CUT_MailBoxListItem> MAILBOX_ITEMS_VECTOR;

// v4.2 allows return of _TCHAR pointers for GetMailBoxListItem overload
class CUT_MailBoxListItemT {
public:
    CUT_MailBoxListItemT() : m_nNameAttrib(0),
		m_strDelimiter(NULL),
		m_strName(NULL)
	{}
	~CUT_MailBoxListItemT() {
		if(m_strDelimiter != NULL) delete [] m_strDelimiter;
		if(m_strName != NULL) delete [] m_strName;
		}
	int		m_nNameAttrib;
	_TCHAR  *m_strDelimiter;
	_TCHAR  *m_strName;

};


/********************************
 CUT_MsgData class
*********************************/
class CUT_MsgDataA {
public:
    CUT_MsgDataA() : m_lFlags(0), m_lUID(0), m_ptrData(NULL), m_nDataType(0)
    {
        m_szUnknownFlags[0] = 0;
        m_szDateTime[0]     = 0;
    }
    
    long    m_lMsgNumber;                           // Message sequence number
    long    m_lSize;                                // Message size
    long    m_lFlags;                               // Message flags
    char    m_szUnknownFlags[MAX_LINE_BUFFER+1];    // Unknown message flags as string
    char    m_szDateTime[MAX_DATE_TIME_SIZE+1];     // Message internal date
    long    m_lUID;                                 // Unique identifier of the message.

    int             m_nDataType;                    // Type of message data (see FetchItem)
    CUT_DataSource  *m_ptrData;                     // Message data 
};

/********************************
 CUT_MsgData class - wide char as of v4.2 for UI
*********************************/
class CUT_MsgData {
public:
    CUT_MsgData() : m_lFlags(0), m_lUID(0), m_ptrData(NULL), m_nDataType(0)
    {
        m_szUnknownFlags[0] = _T('\0');
        m_szDateTime[0]     = _T('\0');
    }
    
    long    m_lMsgNumber;                           // Message sequence number
    long    m_lSize;                                // Message size
    long    m_lFlags;                               // Message flags
    _TCHAR  m_szUnknownFlags[MAX_LINE_BUFFER+1];    // Unknown message flags as string
    _TCHAR  m_szDateTime[MAX_DATE_TIME_SIZE+1];     // Message internal date
    long    m_lUID;                                 // Unique identifier of the message.

    int             m_nDataType;                    // Type of message data (see FetchItem)
    CUT_DataSource  *m_ptrData;                     // Message data 
};
typedef vector<CUT_MsgDataA> MSGDATA_ITEMS_VECTOR;

typedef vector<long> LONG_VECTOR;

/********************************
 CUT_IMAP4Client class
*********************************/
class CUT_IMAP4Client : public CUT_WSClient
{
public:	
    /********************************
     UT_StatusData structure
    *********************************/
    typedef struct UT_StatusDataTag {
        string  m_strName;          // MailBox name
        long    m_lMsgNumber;       // Number of messages
        long    m_lMsgRecent;       // Number of recent messages
        long    m_lMsgUnseen;       // Number of unseen messages
        long    m_lNextUID;         // The next UID value that will be assigned to a new message in the mailbox
        long    m_lUIVV;            // The unique identifier validity value of the mailbox.
        } UT_StatusData;

        BOOL            m_bMailBoxWriteAccess;      // TRUE if we have write access to the mailbox
        long            m_lMailBoxMsgNumber;        // Mailbox messages number
        long            m_lMailBoxMsgRecent;        // Mailbox recent messages number
        long            m_lMailBoxFlags;            // Mailbox system flags
        char            m_szMailBoxUnknownFlags[MAX_LINE_BUFFER+1]; // Unknown message flags
        long            m_lMailBoxPermanentFlags;   // Mailbox system flags
        char            m_szMailBoxPermanentUnknownFlags[MAX_LINE_BUFFER+1];    // Mailbox unknown flags
        long            m_lMailBoxUIVV;             // Mailbox unique identifier validity value
        long            m_lMailBoxMsgUnSeen;        // The number of the first message without the \Seen flag set

private:
        BOOL            m_bFireOnExists;            // If TRUE - fire OnExists event
        BOOL            m_bFireOnRecent;            // If TRUE - fire OnRecent event
        BOOL            m_bFireOnExpunge;           // If TRUE - fire OnExpunge event
        BOOL            m_bFireOnFetch;             // If TRUE - fire OnFetch event

        long            m_lOnExistsParam;           
        long            m_lOnRecentParam;
        long            m_lOnExpungeParam;

protected:
        unsigned int            m_nPort;            // Connect port
        int                     m_nIMAP4TimeOut;    // IMAP4 time out in sec.
        int                     m_nConnectTimeout;  // The wait for connect time out 
        long                    m_lNewMailCheckInterval;    // New mail checking interval in sec.

        char                    m_szLastResponse[MAX_LINE_BUFFER + 1]; // Text data from the last response

        ClientState             m_ClientState;      // Current client state

        MAILBOX_ITEMS_VECTOR    m_vectorListItems;  // MailBox LIST or LSUB command result

        MSGDATA_ITEMS_VECTOR    m_vectorMsgData;    // Message data returned by FETCH respomses

		CUT_MsgData				m_msgData;			// v4.2 used for copy from internal ansi to wc

        LONG_VECTOR             m_vectorSearchResult;   // Serch result vector

        UT_StatusData           m_LastUT_StatusData;    // Data from the last STATUS response

        HANDLE                  m_hNewMailThread;   // New mail thread handle

        CRITICAL_SECTION        m_CriticalSection;  // Critical section

        char                    m_szCapabiltyInfo[MAX_LINE_BUFFER+1];   // IMAP4 capabilty information

        vector<CUT_DataSource*> m_vectorPtrDataSource;  // Vector of allocated messages data

        BOOL                    m_bConnection;      // If TRUE connection is established

        BOOL                    m_bGoingToDestroy;  // TRUE if we are going to destroy the object
protected:

        static void     NewMailThreadEntry(void *ptr);

        int             GetResponse(LPCSTR lpszCmdTag, LPSTR lpszResponseText = NULL, int nBufferSize = 0);

        void            ProcessResponse(LPSTR lpszResponse);

        void            GetNewTag(LPSTR lpszTag, int iBufferSize);

        void            GetFlags(LPCSTR lpszFlags, long &nFlagResult, LPSTR lpszUnknownFlags = NULL, int nBufferSize = -1);

        CUT_DataSource *GetStringData(LPCSTR lpszData);

		int				SocketOnConnected(SOCKET s, const char *lpszName);
public:

        // Constructor/Destructor
        CUT_IMAP4Client();
        virtual ~CUT_IMAP4Client();

        // Set/Get connect port
        int     SetPort(unsigned int newPort);
        unsigned int  GetPort() const;

        // Set/Get connect time out
        int     SetConnectTimeout(int secs);
        int     GetConnectTimeout() const;

        // Set/Get IMAP4 time out
        int     SetIMAP4TimeOut(int timeout);
        int     GetIMAP4TimeOut() const;

        // Set/Get new mail check interval 
        int     SetNewMailCheckInterval(long nInterval);
        long    GetNewMailCheckInterval() const;

        virtual LPCSTR  GetCapability();

        virtual ClientState GetClientState();

        // Connect to the IMAP4 server
        virtual int     IMAP4Connect(LPCSTR mailHost, LPCSTR user,LPCSTR password);
#if defined _UNICODE
        virtual int     IMAP4Connect(LPCWSTR mailHost, LPCWSTR user,LPCWSTR password);
#endif

        // Close the IMAP4 connection 
        virtual int     IMAP4Close();

        // No-operation command
        virtual int     Noop();

        // ****************************
        //  Mailbox operating commands
        // ****************************
        virtual int     MailBoxSelect(LPCSTR lpszMailBoxName);
        virtual int     MailBoxExamine(LPCSTR lpszMailBoxName);
        virtual int     MailBoxCreate(LPCSTR lpszMailBoxName);
        virtual int     MailBoxDelete(LPCSTR lpszMailBoxName);
        virtual int     MailBoxRename(LPCSTR lpszMailBoxName, LPCSTR lpszNewMailBoxName);
        virtual int     MailBoxSubscribe(LPCSTR lpszMailBoxName);
        virtual int     MailBoxUnSubscribe(LPCSTR lpszMailBoxName);
        virtual int     MailBoxList(LPCSTR lpszReferenceName, LPCSTR lpszMailBoxName);
        virtual int     MailBoxLSub(LPCSTR lpszReferenceName, LPCSTR lpszMailBoxName);
		virtual int     GetMailBoxListItem(long lIndex, LPCSTR &lpszName, LPCSTR &lpszDelimiter, int &nAttrib);
		// v4.2 overload returns _TCHAR data in struct
        virtual int     GetMailBoxListItem(long lIndex, CUT_MailBoxListItemT *item);

        virtual int     MailBoxStatus(LPCSTR lpszMailBoxName, LPCSTR lpszStatusName, UT_StatusData &Result);

        virtual int     MailBoxAppend(LPCSTR lpszMailBoxName, CUT_DataSource &source, LPCSTR lpszFlags = NULL,  LPCSTR lpszDateTime = NULL);
        virtual int     MailBoxAppend(LPCSTR lpszMailBoxName, CUT_DataSource &source, int nFlags,  LPCSTR lpszDateTime = NULL) ;
        virtual long    GetMailBoxListSize();

#if defined _UNICODE
        virtual int     MailBoxSelect(LPCWSTR lpszMailBoxName);
        virtual int     MailBoxExamine(LPCWSTR lpszMailBoxName);
        virtual int     MailBoxCreate(LPCWSTR lpszMailBoxName);
        virtual int     MailBoxDelete(LPCWSTR lpszMailBoxName);
        virtual int     MailBoxRename(LPCWSTR lpszMailBoxName, LPCWSTR lpszNewMailBoxName);
        virtual int     MailBoxSubscribe(LPCWSTR lpszMailBoxName);
        virtual int     MailBoxUnSubscribe(LPCWSTR lpszMailBoxName);
        virtual int     MailBoxList(LPCWSTR lpszReferenceName, LPCWSTR lpszMailBoxName);
        virtual int     MailBoxLSub(LPCWSTR lpszReferenceName, LPCWSTR lpszMailBoxName);

        virtual int     MailBoxStatus(LPCWSTR lpszMailBoxName, LPCWSTR lpszStatusName, UT_StatusData &Result);

        virtual int     MailBoxAppend(LPCWSTR lpszMailBoxName, CUT_DataSource &source, LPCWSTR lpszFlags = NULL,  LPCWSTR lpszDateTime = NULL);
        virtual int     MailBoxAppend(LPCWSTR lpszMailBoxName, CUT_DataSource &source, int nFlags,  LPCWSTR lpszDateTime = NULL) ;
#endif

        virtual int     MailBoxCheck();

        virtual int     MailBoxClose();

        // ****************************
        //  Messages operating commands
        // ****************************
        virtual int     MessageExpunge();
        virtual long    GetSearchResultSize();
        virtual int     GetSearchResultItem(long lIndex, long &lItem);
        virtual long    GetMsgDataListSize();
        virtual int     GetMsgDataListItem(long lIndex, CUT_MsgData *&ptrMsgData);

        virtual int     MessageSearch(LPCSTR lpszSerchString, LPCSTR lpszCharSet = NULL, BOOL bUseMsgUID = FALSE);
        virtual int     MessageCopy(LPCSTR lpszMessageSet, LPCSTR lpszMailBoxName, BOOL bUseMsgUID = FALSE);
        virtual int     MessageFetch(LPCSTR lpszMessageSet, FetchItem Item, BOOL bSetSeenFlag = FALSE, BOOL bUseMsgUID = FALSE);
        virtual int     MessageStore(LPCSTR lpszMessageSet, LPCSTR lpszStoreType, LPCSTR lpszFlags, BOOL bUseMsgUID = FALSE);
        virtual int     MessageStore(LPCSTR lpszMessageSet, StoreType nStoreType, int nFlags, BOOL bUseMsgUID = FALSE);

#if defined _UNICODE
        virtual int     MessageCopy(LPCWSTR lpszMessageSet, LPCWSTR lpszMailBoxName, BOOL bUseMsgUID = FALSE);
        virtual int     MessageFetch(LPCWSTR lpszMessageSet, FetchItem Item, BOOL bSetSeenFlag = FALSE, BOOL bUseMsgUID = FALSE);
        virtual int     MessageSearch(LPCWSTR lpszSerchString, LPCWSTR lpszCharSet = NULL, BOOL bUseMsgUID = FALSE);
        virtual int     MessageStore(LPCWSTR lpszMessageSet, LPCWSTR lpszStoreType, LPCWSTR lpszFlags, BOOL bUseMsgUID = FALSE);
        virtual int     MessageStore(LPCWSTR lpszMessageSet, StoreType nStoreType, int nFlags, BOOL bUseMsgUID = FALSE);
#endif

        // Gets system flags names 
        virtual void    FlagsToString(int nStatus, LPSTR lpszBuffer, int nBufferSize);
#if defined _UNICODE
		// v4.2 overloaded - this should still be updated to return error check - refactor next version 
        virtual void    FlagsToString(int nStatus, LPWSTR lpszBuffer, int nBufferSize);
#endif

        // Gets last command response text data
        virtual LPCSTR  GetLastCommandResponseText();

protected:

        virtual void    OnAlertMessage(LPCSTR lpszAlertMsg);

        virtual void    OnExpunge(long nMsgNumber);

        virtual void    OnFetch();
        
        virtual void    OnExists(long nMsgNumber);
        
        virtual void    OnRecent(long nMsgNumber);

        virtual BOOL    NewMailThreadStarted();

        virtual void    NewMailThreadTerminated();

};



#endif  //#ifndef __midl
#endif // End IMAP4_c.h


